<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Shunlqing&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shunlqing&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shunlqing&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Shunlqing's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shunlqing's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">触动、反思，然后重新出发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/16/rvalue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/16/rvalue/" itemprop="url">理解右值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-16T14:40:15+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文关注内容：右值和右值引用，以及移动语义、完美转发。</p>
<h1 id="发现身边的右值"><a href="#发现身边的右值" class="headerlink" title="发现身边的右值"></a>发现身边的右值</h1><p>学习右值之所以会觉得很晦涩难懂，是因为我们完全习惯使用了左值。就像突然哪天告诉你，有“暗物质”的存在，你的“常识世界”是一下子不能接受的。</p>
<p>变量（或者说对象）可以看作是内存中的一小段。程序不断运行达到某种功能都是对若干个位于内存的对象，不断加工、修改的，各个对象又相互联系的结果。</p>
<p>在编程过程中，我们会定义各种变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">class ObjectA &#123;</span><br><span class="line">    ObejctA() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ObjectA a();</span><br></pre></td></tr></table></figure></p>
<p>这些定义操作，编译器会这样做：</p>
<ul>
<li>1.分配一段内存，命名为i，内存大小按照int类型标准分配，然后这段内存初始化为0；</li>
<li>2.分配一段内存，命名为a，内存大小按照ObjectA类型标准分配，然后这段内存根据默认构造函数初始化。<br>这样，在程序的其他地方，我们可以使用变量名i或者a，来达到修改它们所代表的内存的目的。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这就是左值。它们是可以取地址的。它们会有个名字，就像门牌号。程序员可以明确地说：我就要使用某某地址上的那个变量i，我要把它改成1。</p>
<p>那么，内存世界里，除了程序员明确定义的变量占据内存，是否还存在其他构建了的内存对象？答案是有的。在程序编译期间和运行期间，会在内存构造很多没有名字的对象（匿名对象），它们有的为了计算，有的为了支持上层的语言特性。看以下几种情景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = GetValue();</span><br></pre></td></tr></table></figure></p>
<p>运行过程：程序通过GetValue()计算得出一个“结果”，然后将这个结果拷贝到i所命名的内存位置。我们考察这个“结果”（临时值），它同样需要一个和i一样的内存，只是在拷贝给i之后，这段内存就销毁了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectA&#123;</span><br><span class="line">    ObjectA()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectA(const ObjectA&amp; ) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ObjectA() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ObjectA a = ObjectA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用-fno-elide-constructors来取消返回值优化，以便观察临时值的产生。运行结果：</p>
<pre><code>Constructor
Copy constructor
Destructor
Destructor
</code></pre><p>可以看出，这里构造了一个临时对象，然后拷贝给a之后，临时对象就销毁了。</p>
<p>此外，lambda表达式也属于右值，它们在内存中也会以某种对象的形式存在，但是你无法知悉它们的存储位置（获取地址）。</p>
<h1 id="知道右值的存在，我们如何使用右值？"><a href="#知道右值的存在，我们如何使用右值？" class="headerlink" title="知道右值的存在，我们如何使用右值？"></a>知道右值的存在，我们如何使用右值？</h1><pre><code>答案：右值引用。
</code></pre><p>和左值引用一样，<strong>右值引用允许你直接引用匿名对象的那段内存，虽然你无法知悉它的地址，但不影响你使用</strong>。编译器使用&amp;&amp;符号表示右值引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectA &amp;&amp;a = ObjectA(); //语义：直接把临时构造的对象返回给a，a作为这个临时对象的引用供程序员使用。</span><br></pre></td></tr></table></figure></p>
<p>这里运行结果：</p>
<pre><code>Constructor
Destructor
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = []()&#123; return 1; &#125;; //lambda表达式（匿名表达式）可以使用一个右值引用去“承接”它。</span><br><span class="line">f(); //然后就可以使用这个右值引用，在其他地方调用这个lambda表达式</span><br></pre></td></tr></table></figure>
<p>这里要区分好右值和右值引用。右值是一种对象的概念，而右值引用和左值引用一样，是引用。</p>
<h1 id="使用右值，好处多多"><a href="#使用右值，好处多多" class="headerlink" title="使用右值，好处多多"></a>使用右值，好处多多</h1><p>通过前面的描述我们可以看到，很多时候，匿名对象（临时对象）的构造是不为人所知的。很多情况下，匿名对象的生命周期很短。它们被构造，然后在短时间内又被销毁。如果构造对象涉及开销比较大的操作，比如malloc。</p>
<p>我们来看一个配备移动构造函数的类对象的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//没有移动构造函数</span><br><span class="line">class ObjectA &#123;</span><br><span class="line">public:</span><br><span class="line">    ObjectA() : m_ptr(new char[1]) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectA(const ObjectA&amp; a) : m_ptr(new char[*a.m_ptr]) //深拷贝</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~ObjectA() &#123;</span><br><span class="line">        delete[] m_ptr;</span><br><span class="line">        cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ObjectA a = ObjectA(); //产生临时对象，该条语句运行完，临时对象销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>Constructor
Copy Constructor
Destructor
Destructor
</code></pre><p>临时对象分配了动态内存，然后短时间内又析构释放。为了定义一个对象，总共发生了两次的new操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//配备移动构造函数</span><br><span class="line">class ObjectA &#123;</span><br><span class="line">    // ....</span><br><span class="line"></span><br><span class="line">    ObjectA(const ObjectA&amp; a) : m_ptr(new char[*a.m_ptr])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //移动构造函数</span><br><span class="line">    ObjectA(ObjectA &amp;&amp; a) : m_ptr(a.m_ptr) &#123; //</span><br><span class="line">        a.m_ptr = nullptr;</span><br><span class="line">        cout &lt;&lt; &quot;Move Constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>Constructor
Move Constructor
Destructor
Destructor
</code></pre><p>只发生一次new操作。我们将临时对象new的动态内存直接转移给了返回的对象。节省开销。</p>
<p>程序员明确知道，会产生临时变量，而且这个临时变量会在短时间内析构。那么何不将其捕捉，直接利用呢？移动构造函数就是利用这一点。</p>
<h1 id="左值也可转化为右值——std-move"><a href="#左值也可转化为右值——std-move" class="headerlink" title="左值也可转化为右值——std::move()"></a>左值也可转化为右值——std::move()</h1><p>左值是一种对象的概念，右值也是一种对象的概念。说白了，就是内存嘛。那么，一个左值可以用右值的方式看待，从而使用到右值的一些便利呢。答案是可以。</p>
<p>比如，我明确清楚某个对象我不会再使用了，但是里面的资源释放掉蛮可惜的，我希望新的对象或者其他对象直接来承接这些资源。<strong>std::move()</strong>模板函数提供了这样的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ObjectA a = ObjectA();</span><br><span class="line">    </span><br><span class="line">    ObjectA b(std::move(a)); //我们明确不会再使用a,就可以将其所只有的资源转移给新的对象。（具体转移操作由移动拷贝构造完成）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>    Constructor<br>    Move Constructor<br>    Destructor<br>    move …<br>    Move Constructor<br>    Destructor<br>    Destructor</p>
<p>类似具有<strong>转移语义</strong>的函数还有移动赋值语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectA&amp; operator=(ObjectA&amp;&amp; a) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator= &amp;&amp;&quot; &lt;&lt; endl;</span><br><span class="line">    m_ptr = a.m_ptr;</span><br><span class="line">    a.m_ptr = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="完美转发-–std-forward模板"><a href="#完美转发-–std-forward模板" class="headerlink" title="完美转发 –std::forward模板"></a>完美转发 –std::forward模板</h1><p>基本：一个&amp;&amp;的形参可以匹配左值，也可以匹配右值。&amp;&amp;称为universal reference。</p>
<p>需求：函数模板中，需要将参数转发给函数函数模板中调用的另一个函数。传入右值类型，转发的也要保留右值类型，传入左值类型，转发也要保留左值类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void process(int&amp; i) &#123; cout &lt;&lt; &quot;lvalue call, i = &quot; &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">void process(int&amp;&amp; i) &#123; cout &lt;&lt; &quot;rvalue call, i = &quot; &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    process(t); // t是右值引用，但t本身是左值，所以匹配到的是process(int&amp; i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 2;</span><br><span class="line">    func(a); </span><br><span class="line"></span><br><span class="line">    func(10); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>lvalue call, i = 2
lvalue call, i = 10
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    process(std::forward&lt;T&gt;(t)); // t是右值引用，但t本身是左值，所以匹配到的是process(int&amp; i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>lvalue call, i = 2
rvalue call, i = 10
</code></pre><p><strong>使用完美转发和移动语义来实现一个泛型的工厂函数</strong>，这个工厂函数可以创建所有类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename... Args&gt;</span><br><span class="line">T* Instance(Args... args)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[TODO]</p>
<ul>
<li>std::move的实现</li>
<li>std::forward的实现</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/linux_ipc_pipe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/linux_ipc_pipe/" itemprop="url">管道——花园软水管</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T14:31:46+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、小谈管道历史"><a href="#一、小谈管道历史" class="headerlink" title="一、小谈管道历史"></a>一、小谈管道历史</h1><p>关于管道，有这么一句话：</p>
<pre><code>如果说Unix是计算机文明中最伟大的发明，那么，Unix下的Pipe管道就是跟随Unix所带来的另
一个伟大的发明。
</code></pre><p>管道的出现就是为了使软件开发更加“高内聚，低耦合”。管道的发明者，Malcolm Douglas McIlroy，同时也是Unix创建者及Unix文化缔造者，他的Unix哲学：</p>
<pre><code>程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本
数据流，因为这是一个通用的接口。
</code></pre><p>也就是说，管道存在的意义就是让程序能够专注自己的目标，而不同进程之间可以相互通信协作，完成一个更大的目标。比如：在主机上，客户进程可以通过管道给文件服务器进程发送文件名，文件服务器打开文件然后将文件数据通过管道传给客户进程，如此，客户进程和文件服务器相互独立，同时相互协作。这其实不仅仅是管道的特点，同时也是其他进程间通信（IPC）手段的特点。不同的IPC实现各有不同，但是目的、哲学道理都是差不多的。</p>
<p>IPC技术：管道，共享内存，消息队列，信号量，本地套接字等。</p>
<p>管道一般是单向的，半双工的，像花园的软水管，一边进一边出。要想实现全双工，一般需要两条管道。</p>
<h1 id="二、管道基本实现"><a href="#二、管道基本实现" class="headerlink" title="二、管道基本实现"></a>二、管道基本实现</h1><p>每个进程都有自己的独立的地址空间，要想实现进程之间的相互通信，必须采取必要的手段: 共享内存或者借助内核。管道的实现就是借助内核。</p>
<p><img src="http://p1lv91x5b.bkt.clouddn.com/linux_ipc_pipe_impl.png" alt=""></p>
<p>管道的本质就是<strong>内核维护的一段内存</strong>。因为linux“一切皆文件”的思想，管道自然而然就被实现为“管道文件”（向普通文件一样管理），隶属管道文件系统pipefs。因此，和普通文件一样，内核负责维护文件的细节，返回给用户进程的只是一个个“<strong>文件描述符</strong>”，通过文件描述符，进程可以执行打开管道、读写管道的操作。</p>
<p>管道分为两种：无名管道pipe和有名管道FIFO</p>
<p><strong>无名管道pipe</strong></p>
<p>何为无名管道？无名管道就是用户进程只能通过文件描述符fd才能找到的管道，内核没有给其他方式告诉管道在哪里。即没有名字，只有句柄（文件描述符）。一般来讲，文件描述符只会在有亲缘关系的进程间继承，这就限制了无名管道一般只用在有亲缘关系进程间通信。</p>
<p><strong>有名管道FIFO</strong></p>
<p>何为有名管道？有名管道，对比无名管道，它跟实体文件名绑定。任何进程只要知道跟管道绑定的文件名，就可以尝试打开管道并操作。这意味着，有名管道可以使用在没有亲缘关系的进程间通信使用。</p>
<h1 id="三、无名管道pipe"><a href="#三、无名管道pipe" class="headerlink" title="三、无名管道pipe"></a>三、无名管道pipe</h1><h2 id="创建无名管道pipe"><a href="#创建无名管道pipe" class="headerlink" title="创建无名管道pipe"></a>创建无名管道pipe</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> error = pipe(pipefd); <span class="comment">//调用成功，返回两个文件描述符，</span></span><br><span class="line">    管道只读端pipefd[<span class="number">0</span>]和管道只写端pipefd[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h2 id="无名管道使用（搭配进程fork）"><a href="#无名管道使用（搭配进程fork）" class="headerlink" title="无名管道使用（搭配进程fork）"></a>无名管道使用（搭配进程fork）</h2><p>无名管道因其只以文件描述符索引，所以一般的使用方式：</p>
<pre><code>某个祖先进程（父进程）先创建管道，然后fork出若干子进程，父子进程或兄弟进程之间通过继承得到
的管道文件描述符来读写管道，从而达到通信的目的。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">//关闭管道读端或写端描述符</span></span><br><span class="line">        <span class="comment">//write or read</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(childpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">//关闭管道写端或读端描述符</span></span><br><span class="line">        <span class="comment">// read or write</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitpid()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//fork error</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong> ：<strong>管道的双方要关闭不需要使用到的文件描述符，为什么？</strong>这涉及管道读取端如何判断对方已经不再写了？管道写端进程如何判断管道另一头已经没有进程在读了？</p>
<ul>
<li>当读取端已无进程等待（即fd[0]的引用计数为0 （close））, 此时若有进程对写端继续写，返回EPIPE错误。并产生信号SIGPIPE。</li>
<li>当写端已无进程再继续写（即fd[1]的引用计数为0 （close））, 若管道的数据读完，将返回文件结束符EOF。</li>
</ul>
<p>因此，为了能够正常判断结束条件，进程要关闭其没有使用的管道文件描述符。</p>
<p><strong>无名管道是不是只能用在用亲缘关系的进程中？</strong></p>
<pre><code>答案是否定的。因为借助本地套接字，可以在进程间传递文件描述符。
</code></pre><h2 id="popen-pclose"><a href="#popen-pclose" class="headerlink" title="popen/pclose"></a>popen/pclose</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="http://p1lv91x5b.bkt.clouddn.com/linux_ipc_pipe_popen_wtype.png" alt=""></p>
<p><img src="http://p1lv91x5b.bkt.clouddn.com/linux_ipc_pipe_popen_rtype.png" alt=""></p>
<p>popen行为：fork并执行shell进程，shell进程fork并执行command进程，并返回文件描述符。该文件描述符fd或为读端（管道写端关联到command进程的标准输出），或为写端（管道读端关联到command进程的标准输入）。这取决与popen是以读模式还是以写模式打开。</p>
<h1 id="四、命名管道FIFO"><a href="#四、命名管道FIFO" class="headerlink" title="四、命名管道FIFO"></a>四、命名管道FIFO</h1><h2 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 成功，创建一个新的FIFO</span></span><br><span class="line"><span class="comment">// 返回EEXIST错误（指定文件名的FIFO已经存在）</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>path: 文件路径名</li>
<li>mode: 文件权限位</li>
</ul>
<p><strong>创建管道用mkfifo，打开管道用open</strong>  </p>
<p>调用mkfifo成功创建管道后，其他进程可以通过open相应的“文件名”从而获取管道，进行读或写。</p>
<h1 id="五、管道属性"><a href="#五、管道属性" class="headerlink" title="五、管道属性"></a>五、管道属性</h1><h2 id="管道的打开行为、读写行为"><a href="#管道的打开行为、读写行为" class="headerlink" title="管道的打开行为、读写行为"></a>管道的打开行为、读写行为</h2><h3 id="管道open和O-NONBLOCK"><a href="#管道open和O-NONBLOCK" class="headerlink" title="管道open和O_NONBLOCK"></a>管道open和O_NONBLOCK</h3><p>管道默认是阻塞的。和普通文件描述符一样，任何时候可以通过fcntl（瑞士军刀）设置成非阻塞。</p>
<ul>
<li>管道阻塞， open + O_RDONLY : 此时没有进程为写打开，则阻塞。</li>
<li>管道阻塞， open + O_WRONLY ：此时没有进程为读打开，则阻塞。</li>
<li>管道非阻塞， open + O_RDONLY : 无论有没有进程为写打开，立即返回。</li>
<li>管道非阻塞， open + O_WRONLY ： 没有读进程，则返回-1，errno = ENXIO。</li>
</ul>
<h2 id="管道读写"><a href="#管道读写" class="headerlink" title="管道读写"></a>管道读写</h2><ul>
<li>阻塞、空管道或FIFO，read：有写进程，阻塞到有数据；无写进程，返回EOF；</li>
<li>非阻塞、空管道或FIFO，read: 有写进程，返回EAGAIN；无写进程，返回EOF；</li>
<li>阻塞、管道或FIFO，write: 有读进程，见下文；无读进程，返回SIGPIPE；</li>
<li>非阻塞、管道或FIFO，write: 有读进程，见下文；无读进程，返回SIGPIPE；</li>
</ul>
<h3 id="管道写行为、PIPEBUF、原子性"><a href="#管道写行为、PIPEBUF、原子性" class="headerlink" title="管道写行为、PIPEBUF、原子性"></a>管道写行为、PIPEBUF、原子性</h3><p>管道有一特点，尽力保证写入的原子性：</p>
<pre><code>如果请求写入的数据字节数小于等于PIPE_BUF，那么write操作保证是原子的。大于PIPE_BUF，则不保证。
</code></pre><p>如此，在非阻塞情况下：</p>
<ul>
<li>请求写入字节数小于等于PIPE_BUF:<ul>
<li>当前管道空间足够，则直接写入；</li>
<li>当前管道空间不够，为保证原子性，先返回EAGAIN，告诉进程稍后尝试；</li>
</ul>
</li>
<li>请求写入字节数大于PIPE_BUF：<ul>
<li>当前管道空间至少还有1字节，直接写相应字节数，返回；</li>
<li>当前管道满，返回EAGAIN。</li>
</ul>
</li>
</ul>
<p>PIPE_BUF的大小可以通过fcntl来设置。</p>
<p>从上面的讨论可以看出，管道的读写需要一些技巧。所谓“管道有大小，写入需谨慎”。</p>
<ul>
<li>一次写入数据量不超过PIPE_BUF，以保证写入是原子的。即使存在多个进程同时读，也不会被打断。</li>
<li>写端不要大量输入，会造成阻塞。</li>
<li>读端，要及时读取，避免造成写入阻塞。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/Advance_IO_Func/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/Advance_IO_Func/" itemprop="url">高级IO函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T16:47:46+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>讨论几个问题：</p>
<ul>
<li>为避免函数调用不可预期的永久阻塞，可以对IO操作设置超时，设置超时有哪些方法？</li>
<li>最基本的读写函数read/write，及其各种变体（send, recv, recvmsg….）是什么样的关系？</li>
<li>如果仅仅想查看套接字接收缓冲区的数据而不读取，要怎么做？</li>
</ul>
<h1 id="二、为套接字设置超时"><a href="#二、为套接字设置超时" class="headerlink" title="二、为套接字设置超时"></a>二、为套接字设置超时</h1><p>抛出各种具体方法：</p>
<ul>
<li>信号中断：alarm函数 + SIGALRM信号（缺点:干扰程序正常alarm的使用，在多线程程序中使用信号很困难）</li>
<li>select保安：利用select可以设置超时，让select代为阻塞等待在IO上。</li>
<li>套接字选项：SO_RCVTIMEO和SO_SNDTIMEO（不能用于connect设置超时）</li>
</ul>
<h1 id="三、读写函数的各种变体"><a href="#三、读写函数的各种变体" class="headerlink" title="三、读写函数的各种变体"></a>三、读写函数的各种变体</h1><p>基本read/write及其三种变体send/recv、readv/writev和recvmsg/sendmsg</p>
<p>简要对比：</p>
<ul>
<li>send/recv对比read/write多了一个flags参数，可以传给内核；</li>
<li>readv/writev对比read/write，后者是单个缓冲区的读写，前者则可以支持在单个系统调用中实现多个缓冲区的读写，称为“分散读”和“集中写”。</li>
<li>recvmsg/sendmsg是最通用的函数，它集中了前面集中的所有特性。但是这组只能在套接字描述符中使用。</li>
<li>sendto/recvfrom一般只在UDP套接字中使用。</li>
</ul>
<h2 id="send-recv"><a href="#send-recv" class="headerlink" title="send/recv"></a>send/recv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recv(int sockfd, void* buff, size_t bytes, int flags);</span><br><span class="line">ssize_t send(int sockfd, const void* buff, size_t bytes, int flags);</span><br></pre></td></tr></table></figure>
<p><strong>flags</strong>——值参数</p>
<ul>
<li>MSG_DONTROUTE: 发送操作无须路由，仅限发送操作。表示目的主机在某个直接连接的本地网络上。</li>
<li><strong>MSG_DONTWAIT</strong>：单次操作“非阻塞”。</li>
<li>MSG_OOB:对于send,表示即将发送的数据是带外数据（对于TCP只有一个字节）；对于recv表示，即将读入的是带外数据而不是普通数据。</li>
<li><strong>MSG_PEEK</strong>:表示仅查看可读取的数据，不作读取。适用于recv和recvmsg。</li>
<li><strong>MSG_WAITALL</strong>:表示尚未读到请求数目的字节之前不让一个读操作返回。意外情况:a. 捕获一个信号；b.连接被终止；c.套接字发生错误，相应的读函数仍旧可能返回少于请求数目的数据。</li>
</ul>
<h2 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv/writev"></a>readv/writev</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/io.h&gt;</span><br><span class="line">ssize_t readv(int flags, const struct iovec *iov, int iovcnt);</span><br><span class="line">ssize_t writev(int flags, const struct iovec *iov, int iovcnt);</span><br><span class="line"></span><br><span class="line">struct iovec &#123;</span><br><span class="line">    void *iov_base; //缓冲区起始地址</span><br><span class="line">    void *iov_len; //缓冲区长度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>writev是原子调用，对于数据报协议，一次writev调用只会产生一个UDP数据报。</li>
<li>writev的一个用途：将小包数据经过整合，使用writev发送，可以有效防止Nagle算法的触发。</li>
</ul>
<h2 id="recvmsg-sendmsg"><a href="#recvmsg-sendmsg" class="headerlink" title="recvmsg/sendmsg"></a>recvmsg/sendmsg</h2><p>具体参见UNP14.6</p>
<h1 id="四、获悉已排队的数据量"><a href="#四、获悉已排队的数据量" class="headerlink" title="四、获悉已排队的数据量"></a>四、获悉已排队的数据量</h1><p>方法：</p>
<ul>
<li>如果获悉已排队数据量的目的在于不想阻塞，那么可以使用非阻塞调用。</li>
<li>如果既想查看数据，有想保留数据在接收队列中以供本进程其他部分稍后读取，可以使用MSG_PEEK。通常需要结合非阻塞+PEEK，要么是非阻塞套接字+MSG_PEEK,或者阻塞+MSG_DONTWAIT+MSG_PEEK。对于TCP，先只“获悉”，再次“读取”，两次调用的返回数据长度可能是不同的；对于UDP，两次调用的返回数据是完全相同的。</li>
<li>ioctl + FIONREAD, 通过第三个参数（值——结果）返回当前接收队列的字节数。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/16/static/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/static/" itemprop="url">static关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T16:30:09+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="何时使用static"><a href="#何时使用static" class="headerlink" title="何时使用static"></a>何时使用static</h1><ul>
<li>请况一:当我们定义一个函数,该函数仅限于在定义它的源文件下使用,此时可以使用”static”修饰,以对外界隐藏该函数.</li>
<li>情况二:同样,定义一个全局变量,该变量仅在定义它的源文件下使用,此时可以使用”static”修饰,达到隐藏的目的.</li>
<li>情况三:对于一个局部变量,如果我们有意不让其存储在栈(自动变量)上,而是存储在静态存储区(.data,.bss),可以使用static修饰.<br>前两种情况都是限定符号的作用域,第三种情况属于改变变量的生命周期.</li>
</ul>
<h1 id="static的作用如何实现的"><a href="#static的作用如何实现的" class="headerlink" title="static的作用如何实现的"></a>static的作用如何实现的</h1><p>首先清楚c/c++的分离式编译,每个.c文件都首先经过编译成目标文件(.o文件),再经过链接形成可执行文件。</p>
<p><strong>static</strong>修改链接属性</p>
<p>使用static修饰全局变量或者函数，其实修饰的都是符号。对编译其来说，以static修饰的符号，其属性的本地属性，即在链接的时候，不会被链接器处理。这样就达到了向外界（其他目标文件）隐藏的目的。</p>
<p>static局部变量（静态局部变量）</p>
<p>静态局部变量仅仅是编译器在编译的时候，在程序的静态存储区（.bss,.data）为该变量预留空间。未初始化的静态局部变量存储在.bss段，已初始化的静态局部变量存储在.data。其生命周期就从初始化时刻到程序结束。栈上变量（自动变量）的生命周期只局限函数内部。</p>
<h1 id="static和extern"><a href="#static和extern" class="headerlink" title="static和extern"></a>static和extern</h1><p>extern并不能改变static的作用效果。</p>
<p>extern关键字的作用仅仅是告诉编译器，该符号的定义在外部。</p>
<ul>
<li>对于全局变量来说，extern的作用是告诉编译器，该符号在其他源文件里面。</li>
<li>对于函数来说，extern的作用和#include “*.h”的作用是相似的，相当于声明。在两个目标模块的联系仅仅是几个函数，就可以使用这种方法，而不需要include包含整个头文件。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/15/NB_IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/NB_IO/" itemprop="url">非阻塞式IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T21:54:46+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="阻塞与非阻塞的概念"><a href="#阻塞与非阻塞的概念" class="headerlink" title="阻塞与非阻塞的概念"></a>阻塞与非阻塞的概念</h2><p>在用户进程或者线程进行系统调用进入内核的时候，如果不能马上满足条件，内核对调用者采取不同的行为，分为<strong>“阻塞”和”非阻塞“</strong>两种。”<strong>阻塞</strong>“表示如果系统调用不能马上获得满足而返回，就将调用者（进程或线程）挂起，等到满足条件，内核执行完系统调用，重新恢复调用者。”<strong>非阻塞</strong>“表示如果系统调用不能满足，则立即返回，并设置错误信息以告知调用者，该系统调用因何不能满足。</p>
<p>从以上看，”阻塞“虽然使用比较简单，但是<strong>很被动</strong>，会出现”永久阻塞“而导致无法处理的问题，设想一下，客户端进程阻塞等待接受服务器的消息，但是这个服务器因为某种原因崩溃了，如此客户端就会永久阻塞。相反，”非阻塞“技术给了程序员更大的灵活性，只要能够合理处理各种情况便能够更好的提高效率。</p>
<p>总之，非阻塞调用相对与阻塞调用有几个好处:</p>
<ul>
<li>不会出现“永久阻塞”（设置超时也可解决永久阻塞问题）</li>
<li>同时监听多个IO复用的程序模型，如果使用阻塞调用，可能出现顾此失彼的情况。即，系统调用阻塞在某个IO上时，可能有另一个IO已经就绪，而它不能被及时响应。</li>
</ul>
<p>也因为如此，使用非阻塞技术要体现这些优势。</p>
<h2 id="网络编程背景下的非阻塞式IO"><a href="#网络编程背景下的非阻塞式IO" class="headerlink" title="网络编程背景下的非阻塞式IO"></a>网络编程背景下的非阻塞式IO</h2><p>可能阻塞的套接字调用分为以下四类：</p>
<ul>
<li>输入操作（read、readv、recv、recvfrom、recvmsg五个函数）</li>
<li>输出操作(write、writev、send、sendto、sendmsg五个函数)</li>
<li>接受外来连接，accept函数</li>
<li>发起外出连接，用于TCP的connect函数</li>
</ul>
<h1 id="二、非阻塞读和写"><a href="#二、非阻塞读和写" class="headerlink" title="二、非阻塞读和写"></a>二、非阻塞读和写</h1><p>UNP给出一个数据，echo服务下的客户端不同版本str_cli函数，测试从一个Solaris客户主机想RTT为175毫秒的一个服务器主机复制2000行文本，所花时间的不同：</p>
<ul>
<li>354.0s，停等版本</li>
<li>12.3s，select+阻塞式IO版本</li>
<li>6.9s, select+非阻塞IO版本</li>
<li>8.7s, fork版本（多进程）</li>
<li>8.5s，多线程版本<br>从这个数据可以看出：</li>
<li>一、IO复用模型的使用确实大大加快了IO的处理</li>
<li>二、IO复用模型搭配非阻塞技术可以再提高效率（但是会提高编程的复杂性）</li>
</ul>
<p>UNP推荐：相对于select+非阻塞IO，最好使用效率差不多、但是编程更简单的多进程模型。</p>
<h2 id="对UNP书上str-cli函数的select-非阻塞式IO的注解"><a href="#对UNP书上str-cli函数的select-非阻塞式IO的注解" class="headerlink" title="对UNP书上str_cli函数的select+非阻塞式IO的注解"></a>对UNP书上str_cli函数的select+非阻塞式IO的注解</h2><p>本版本需要做的工作：</p>
<ul>
<li>维护两个缓冲区;</li>
<li>使用selectIO复用，监听并处理四个IO;</li>
<li>对所有监听的IO都设置成非阻塞IO;</li>
<li>恰当处理终止条件，当服务器终止连接或者客户端标准输入得到EOF;</li>
</ul>
<p>动态性强，但是编程要考虑的情况多。UNP提供了效率差不多，但是编程简单的fork版本。该版本做的工作较少：</p>
<ul>
<li>fork出子进程，负责阻塞等待套接字可读，并将收到的消息输出到标准输出；</li>
<li>父进程负责阻塞等待标准输入可读，并将收到的消息写入套接字；</li>
</ul>
<h1 id="三、非阻塞connect"><a href="#三、非阻塞connect" class="headerlink" title="三、非阻塞connect"></a>三、非阻塞connect</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/UDP_socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/UDP_socket/" itemprop="url">基本UDP编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T20:27:03+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UDP-用户数据报协议"><a href="#UDP-用户数据报协议" class="headerlink" title="UDP 用户数据报协议"></a>UDP 用户数据报协议</h1><p>TCP的通信流程好比“打电话”，拨通号码，需要等对方接起电话（建立了通话渠道），才能进行交流。UDP的通信流程就好比“写信件”，写好信，填好对方的地址和名字，就可以寄出去了。如果没有告知对方，对方并不会知道他将会收到你的一封信。可能因为某些原因（信在运输被弄掉了等等），对方收不到你的信，你也不知道对方收到了没有。更糟糕的是，信可能到对方家里了，但是他不在，或者没有从邮箱里拿出你的信。类似信件的通信行为，UDP把用户进程每次传过来的数据不加拆解、完整的打包成udp数据包交给IP协议层。</p>
<p>UDP协议面向非连接。“非连接”怎么理解？就是说，UDP不管通信对方是否准备好接收消息，甚至不管对方是不是存在。直接把数据打包交给IP层去发送就是了。不像TCP，需要建立起一个连接，才能发送数据。</p>
<p>UDP协议是不可靠的。适用于一次传输数据量较少的通信。</p>
<h1 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h1><h1 id="UDP基本通信模型"><a href="#UDP基本通信模型" class="headerlink" title="UDP基本通信模型"></a>UDP基本通信模型</h1><p>请求——应答模式</p>
<p>&lt;…此处应有图&gt;</p>
<h1 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h1><p>这两个函数是UDP下的读写函数，类似于标准的read和write函数。可以说，这两个函数就是为UDP而生的。为什么这样说呢？</p>
<p>因为UDP是不建立连接的数据传输，这里隐含：对于一个udp套接字，它可以一会儿发给a服务器，一会发给b服务器。同样，它可以接受来自不同IP主机的数据包。（只要知道其地址和端口号就行了）。也就是说，<strong>每次发送/接收的行为都是独立的，那么怎么区分数据包呢？</strong>解决方法就是在read/write函数加两个参数：地址结构体及其长度。这也就演变出两个函数：recvfrom和sendto.</p>
<p>TCP是面向连接的，单向的。recvfrom/sendto没有必要使用在TCP上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvfrom(int sockfd, void* buff, size_t hbytes, int flags, struct sockaddr* from, socklen_t *addrlen);</span><br><span class="line">ssize_t sendto(int sockfd, const void* buff, size_t nbytes, int flags, struct sockaddr* to, socklen_t addrlen);</span><br></pre></td></tr></table></figure></p>
<p>针对这两个函数，注意几点：</p>
<ul>
<li>recvfrom的地址结构及其长度参数都是指针类型，即“值——结果”参数。sendto的地址结构长度是“值”类型。</li>
<li>recvfrom返回值为0是允许的，且不像TCP，返回0就代表对端关闭连接。对于UDP来说，写一个长度为0的数据报是允许的。</li>
<li>recvfrom的地址结构指针是NULL，那么其长度也必须为NULL，表示我们不关心数据发送者的协议地址。</li>
</ul>
<h1 id="各种小问题"><a href="#各种小问题" class="headerlink" title="各种小问题"></a>各种小问题</h1><h2 id="数据报丢了。。。"><a href="#数据报丢了。。。" class="headerlink" title="数据报丢了。。。"></a>数据报丢了。。。</h2><p>客户端sendto一个数据报之后，就兴高采烈转入recvfrom中阻塞等待接收。凡是都有万一，万一数据报在路上被路由器丢弃了，或者服务器根本不存在，又或者服务器返回应答了但是应答丢了。。。会出现什么情况：客户端永久阻塞在recvfrom调用。</p>
<p>一般的解决方法是：给recvfrom调用设置一个超时。</p>
<h2 id="数据报不请自来——验证响应"><a href="#数据报不请自来——验证响应" class="headerlink" title="数据报不请自来——验证响应"></a>数据报不请自来——验证响应</h2><p>客户端或服务器本来在等待A端的数据包，但是却接收到了非A的数据报。如果应用进程不想与之通信，就需要有机制来忽略或处理这样的情况。</p>
<p>解决方法：通过recvfrom传回来的地址结构来判断是否是我们想要的响应。</p>
<h2 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h2><p>客户端在未获知服务器是否启动的情况下，就像服务器发送数据包，会发生这样的情况，即服务器进程还没有启动时，客户端就sendto一个数据包，然后直接转入到recvfrom中，那么什么也不会发生。客户端将永远阻塞在recvfrom。为什么是这样的？</p>
<p>针对IP协议来说，如果目标进程不可达，服务器端将会返回一个“端口不可达”<strong>ICMP错误</strong>（异步错误）。但是在默认情况（未连接）下，这个错误是不会被发送进程感知到的（原因后解）。</p>
<p>sendto成功返回仅仅表示在接口输出队列中具有足够的空间存放本次发送形成的IP数据报。也就不能说明对方已经收到数据报。</p>
<p>一个<strong>基本规则</strong>就是：对于一个UDP套接字，由他引发的异步错误并不返回给套接字本身，除非该UDP套接字已经连接。为什么这样做呢？原因其实很简单，想象一个场景，一个未连接UDP套接字同时发给多个不同的主机，其中有个主机响应了ICMP错误，如果将此异步错误传递给UDP套接字，那么它也判断不了是哪个通信方出现问题。已连接的UDP套接字可以感知到ICMP错误，就是因为它仅仅只有一个对端。</p>
<p>一言：UDP套接字进程感知不了ICMP错误，除非它是已连接的。</p>
<h2 id="UDP的connect行为"><a href="#UDP的connect行为" class="headerlink" title="UDP的connect行为"></a>UDP的connect行为</h2><p>与TCP的connect操作有三次握手过程不同，UDP的connect仅仅是检查是否存在立即可知的错误（地址是不是错误的），把套接字的目标地址和目标端口提前填好而已。</p>
<p>设置好目的IP和目的端口的UDP套接字称为“已连接UDP套接字”。它与未连接UDP套接字有三处不同：</p>
<ul>
<li>设置好目的IP和目的端口号，也就不用每次调用sendto和recvfrom这样需要填地址结构的函数了，可以像TCP一样，调用write/send。</li>
<li>同样的，recvfrom也不必使用，而改用read、recv或recvmsg。</li>
<li>由已连接UDP套接字引发的异步错误将返回它们所在的进程，而未连接UDP套接字不接受任何异步错误。</li>
</ul>
<p>已连接UDP套接字只是确定在当下要通信的对端，是可变的。改变目的IP和目的端口的方法就是再次调用connect。</p>
<p><strong>已连接和未连接UDP套接字的性能</strong></p>
<p>在一个未连接的UDP套接字上调用两次sendto函数，内核行为经历6个步骤：</p>
<ul>
<li>连接套接字；</li>
<li>输出第一个数据报；</li>
<li>断开套接字连接；</li>
<li>连接套接字；</li>
<li>输出第二个数据报；</li>
<li>断开套接字连接；</li>
</ul>
<p>在一个已连接的UDP套接字上调用两次sendto函数，内核行为经历6个步骤：</p>
<ul>
<li>连接套接字；</li>
<li>输出第一个数据报；</li>
<li>输出第二个数据报；</li>
<li>断开套接字连接；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/process_environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/process_environment/" itemprop="url">进程环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T14:51:41+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>讨论进程环境中几个点：</p>
<ul>
<li>进程终止：exit和_exit的关系</li>
<li>环境变量的设置,putenv的陷阱</li>
<li>内存问题</li>
<li>longjmp的原理与陷阱</li>
</ul>
<h1 id="exit和-exit"><a href="#exit和-exit" class="headerlink" title="exit和_exit"></a>exit和_exit</h1><p>当一个进程正常终止时，系统需要做一系列的处理。这里涉及到两个层面：C库和内核的处理：</p>
<ul>
<li>C库层做的工作：刷新IO缓冲区，执行所有注册的退出函数；</li>
<li>内核层做的工作：回收进程所持有的一些资源；</li>
</ul>
<p>进程正常退出时，先执行exit函数(C库层面)，再在exit函数里面调用_exit陷入内核，执行内核退出进程的操作。但异常退出又是怎么样的呢？异常退出只会执行内核退出进程的操作。</p>
<p>正常退出：</p>
<ul>
<li>main使用return；return(n)相当于exit(n);</li>
<li>直接使用exit(n)</li>
</ul>
<p>异常退出：</p>
<ul>
<li>使用_exit(n),因为没有正常执行C库层面的清理工作，所以我们把它归纳到异常状况。但是有时候_exit是必要的，比如多进程的时候。</li>
<li>信号中断。当出现信号中断，信号中断很多的处理都是进程终止，此时执行的直接是内核退出进程的操作，不会返回到C库执行清理工作。</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure>
<p>exit()执行的动作：</p>
<ul>
<li>调用注册的退出处理程序（通过atexit()和on_exit()注册的函数），其执行顺序与注册顺序相反（函数栈）</li>
<li>刷新stdio流缓冲区</li>
<li>使用由status提供的值执行_exit()系统调用。</li>
</ul>
<h2 id="exit-1"><a href="#exit-1" class="headerlink" title="_exit()"></a>_exit()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>
<p>_exit()是系统调用，即其直接陷入内核，执行内核退出进程的操作（该操作无论是进程正常终止还是异常终止都会执行）</p>
<h2 id="内核退出进程的操作"><a href="#内核退出进程的操作" class="headerlink" title="内核退出进程的操作"></a>内核退出进程的操作</h2><ul>
<li>关闭文件描述符（释放任何文件锁），目录流</li>
<li>分离共享内存段</li>
<li>信号量</li>
<li>取消该进程调用mmap所创建的任何内存映射</li>
<li>等等。。。</li>
</ul>
<h2 id="使用atexit注册退出处理程序"><a href="#使用atexit注册退出处理程序" class="headerlink" title="使用atexit注册退出处理程序"></a>使用atexit注册退出处理程序</h2><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int putenv(char *string);</span><br><span class="line">int setenv(const char * name, const char *value, int overwrite);</span><br></pre></td></tr></table></figure>
<p>关键注意点：</p>
<ul>
<li>putenv直接使用的是string的内存空间，即需要保证string指向的变量长期存在，全局变量或动态内存等；setenv不存在这个问题，它会做相应的拷贝。</li>
<li>putenv参数形式，string的格式是“名字=值”；setenv参数分开</li>
</ul>
<h1 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h1><h2 id="慎用realloc"><a href="#慎用realloc" class="headerlink" title="慎用realloc"></a>慎用realloc</h2><h2 id="防止内存越界的几个新旧函数"><a href="#防止内存越界的几个新旧函数" class="headerlink" title="防止内存越界的几个新旧函数"></a>防止内存越界的几个新旧函数</h2><p><strong>使用strncat替代strcat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strncat(char *dest, const char * src, size_t n);</span><br></pre></td></tr></table></figure></p>
<p>从src中最多追加n个字符到dest字符串的后面。该函数自动追加‘\0’到dest的后面，所以<strong>n应该为dest可用空间减1</strong>。</p>
<p><strong>使用strncpy代替strcpy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strncpy(char *dest, const char *src, size_t n);</span><br></pre></td></tr></table></figure></p>
<p>从src中最多复制n个字符到dest字符串中。需要预留‘\0’的一个字节，并手动添加‘\0’。</p>
<p><strong>使用snprintf代替sprintf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int snprintf(char *src, size_t size, const char* format, ...);</span><br></pre></td></tr></table></figure></p>
<p>包含‘\0’，最多复制size个字符。</p>
<p><strong>使用fgets代替gets</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *gets(char *str);</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br></pre></td></tr></table></figure></p>
<p>gets函数从来不检查缓冲区的大小。fgets最多会复制size-1字节到缓冲区s中，并且会在最后一个字符后面自动追加‘\0’。</p>
<h2 id="如何定位内存问题——Valgrind"><a href="#如何定位内存问题——Valgrind" class="headerlink" title="如何定位内存问题——Valgrind"></a>如何定位内存问题——Valgrind</h2><p>常见内存问题：</p>
<ul>
<li>动态内存泄露:malloc,free</li>
<li>资源泄露，如文件描述符</li>
<li>动态内存越界</li>
<li>数组越界</li>
<li>动态内存double free</li>
<li>使用野指针</li>
</ul>
<h1 id="“长跳转”longjmp"><a href="#“长跳转”longjmp" class="headerlink" title="“长跳转”longjmp"></a>“长跳转”longjmp</h1><p>goto是在函数内部实现短跳转，要实现跨函数跳转，得使用长跳转longjmp。</p>
<h2 id="longjmp的原理"><a href="#longjmp的原理" class="headerlink" title="longjmp的原理"></a>longjmp的原理</h2><p>和进程切换、信号中断返回的思想类似，要想实现非正常执行流的跳转，就需要进程在某一时刻的上下文。只要有进程上下文，将其装填到寄存器中，就能够实现跳转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int setjmp(jmp_buf env);</span><br><span class="line">void longjmp(jmp_buf env, int val);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>setjmp使用jmp_buf结构体保存调用时刻的进程上下文，此结构变量需保证在longjmp时时存在的。</li>
<li>setjmp返回0时，为直接返回结果；返回非0值，为longjmp恢复栈空间返回的结果。</li>
<li>跳转一次之后，env保存的上下文就失效了。</li>
</ul>
<h2 id="longjmp的陷阱"><a href="#longjmp的陷阱" class="headerlink" title="longjmp的陷阱"></a>longjmp的陷阱</h2><p>长跳转的实现原理是对与栈相关的寄存器的保存和恢复。</p>
<p><strong>全局变量和static变量</strong></p>
<p>保存在静态存储区，所以longjmp之后不会改变，不影响；</p>
<p><strong>局部变量</strong></p>
<p>满足一下条件的局部变量的值是不不确定的</p>
<ul>
<li>调用setjmp所在函数的局部变量</li>
<li>其值在setjmp和longjmp之间有变化</li>
<li>没有被声明为volatile变量</li>
</ul>
<p><strong>C++析构函数</strong></p>
<p>调用longjmp之后，没有正常解栈，本该调用的析构函数没有调用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    longjmp(g_stack_env);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    对象test的析构函数没有调用。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/inline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/inline/" itemprop="url">inline函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T14:51:31+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引子程序"><a href="#引子程序" class="headerlink" title="引子程序"></a>引子程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// file.cc</span><br><span class="line">inline void foo(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*函数体*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// file.h</span><br><span class="line">void foo(void);</span><br><span class="line"></span><br><span class="line">// main.cc</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的编码会出现什么问题? 链接错误,显示foo未定义(undefined reference to `foo()’).</p>
<h1 id="编译器对inline函数的处理"><a href="#编译器对inline函数的处理" class="headerlink" title="编译器对inline函数的处理"></a>编译器对inline函数的处理</h1><p>使用inline函数,意图是在函数调用处直接替换成函数体,省去函数调用,提高函数的执行效率.但编译器在处理的时候,真正的处理流程是什么样的呢?</p>
<p>我们知道,c/c++程序编译分为几个阶段,预处理-&gt;编译+汇编-&gt;链接.<strong>inline的处理阶段发生在编译阶段.</strong>也就是说,在编译阶段完成后,目标模块的inline函数要么被替换了,要么没有被替换,但是链接时可以找到inline函数的定义.也就是说,在编译阶段之前,目标模块需要看到inline函数的实现.</p>
<p>拿引子程序来说,编译main.o目标模块时,编译器”看到”了foo的声明,此时它并不知道foo是要inline的.编译file.o目标模块时,编译器看到foo的实现,并且声明为inline,由于foo在file.o没有被使用到,所以,inline函数不被保留.链接的时候,当然也就找不到foo的定义实体了.针对此例子,我们可以在file.c定义一处函数,使用了一次foo(),编译就可以通过.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//file.cc</span><br><span class="line">int foo2()</span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正确的做法是,inline函数的实现(定义)要跟随其函数声明放在.h文件中.编译器在编译阶段就可以看见函数实现,从而进行替换.(这一点有点向函数模板,函数模板也是要放在声明文件中,不能单独放在源文件中)</p>
<h1 id="inline和宏的区别"><a href="#inline和宏的区别" class="headerlink" title="inline和宏的区别"></a>inline和宏的区别</h1><ul>
<li>1.宏define在预处理阶段完成；inline在编译阶段完成；</li>
<li>2.类型安全检查，inline是函数，需要做类型检查；</li>
<li>3.替换方式：宏是字符串拷贝替换，会出现边际效应；inline是嵌入代码，在编译过程中不单独产生代码。</li>
<li>4.宏不可调试，inline函数可以调试。这里的“调试”之意是指在程序的debug版本是没有内联的，编译器会生成像普通函数一样含有调试信息的可执行代码。在release版本，才实现真正的内联。</li>
<li>5.inline函数可以操作私有数据成员。</li>
</ul>
<h1 id="内联函数的使用"><a href="#内联函数的使用" class="headerlink" title="内联函数的使用"></a>内联函数的使用</h1><h2 id="inline函数的编程风格"><a href="#inline函数的编程风格" class="headerlink" title="inline函数的编程风格"></a>inline函数的编程风格</h2><p>关键字inline必须与函数定义放在一起才能使函数真正内联,仅把inlilne放在函数声明的前面不起任何作用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Foo不能内联</span><br><span class="line">inline void Foo(int x, int y);</span><br><span class="line">void Foo(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Foo内联</span><br><span class="line">void Foo(int x, int y);</span><br><span class="line">inline Foo(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inline是一种”用于实现的关键字”,而不是一种”用于声明的关键字”.</p>
<h2 id="慎用内联"><a href="#慎用内联" class="headerlink" title="慎用内联"></a>慎用内联</h2><ul>
<li>如果函数体内的代码过长,使用内联将导致可执行代码膨胀过大</li>
<li>如果函数体内的代码出现循环或者其他复杂的控制结构,那么执行函数体内代码的时间比函数调用的开销大得多,因此内联的意义不大.</li>
</ul>
<h2 id="不要轻易让构造函数和析构函数成为内联函数"><a href="#不要轻易让构造函数和析构函数成为内联函数" class="headerlink" title="不要轻易让构造函数和析构函数成为内联函数"></a>不要轻易让构造函数和析构函数成为内联函数</h2><h2 id="inline仅仅是对编译器的一种请求-编译器可以无视"><a href="#inline仅仅是对编译器的一种请求-编译器可以无视" class="headerlink" title="inline仅仅是对编译器的一种请求,编译器可以无视"></a>inline仅仅是对编译器的一种请求,编译器可以无视</h2><h2 id="inline常跟static一起"><a href="#inline常跟static一起" class="headerlink" title="inline常跟static一起"></a>inline常跟static一起</h2><p>当多个源文件包含同一个inline函数，但是编译器又无视inline请求，如此一来，在每个目标模块中都有该函数的实现实例，造成重定义错误。把inline函数同时声明为static函数（限制其作用域为源文件内部），可以解决问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/linux文件IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/linux文件IO/" itemprop="url">linux文件IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T14:51:31+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/技术笔记/" itemprop="url" rel="index">
                    <span itemprop="name">技术笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件描述符和句柄"><a href="#文件描述符和句柄" class="headerlink" title="文件描述符和句柄"></a>文件描述符和句柄</h1><p>句柄，从一般意义上讲，句柄作为内核与用户的交互。用户无法指定内核对象的本体，内核可以提供一个整数值，在内核创建内核对象的时候，返回给用户。用户在想调用该对象的时候，可以指定。</p>
<p>例如，文件在内核的活动对象是一个个file结构，对于用户来说，文件描述符代表这一个文件的标识。用户可以指定文件描述符，内核通过查找来找到文件管理结构file.</p>
<p>因此，文件描述符可以称为“文件句柄”。</p>
<h1 id="内核文件表"><a href="#内核文件表" class="headerlink" title="内核文件表"></a>内核文件表</h1><p>每个进程管理一张打开文件表，用以管理当前进程所打开的文件，称为“进程打开文件表”，保存在task_struct-&gt;files字段，是一个files_struct结构体。</p>
<p>files_struct结构的功能是管理一个file结构<strong>指针</strong>数组，<strong>文件描述符</strong>就是用来索引该数组，从而找到真正的文件管理结构file.此外，files_struct的两个重要字段：</p>
<ul>
<li>close_on_exec_init: 表示当执行exec时要关闭的文件描述符位图</li>
<li>open_fds_init: 保存打开的文件描述符位图</li>
</ul>
<h1 id="文件管理结构file"><a href="#文件管理结构file" class="headerlink" title="文件管理结构file"></a>文件管理结构file</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    /*...*/</span><br><span class="line">    const struct file_operations *f_op; 与该文件相关联的操作函数</span><br><span class="line">    atomic_t f_count; 文件的引用计数(有多少进程打开该文件)</span><br><span class="line">    unsigned int f_flags; 对应于open时指定的flag</span><br><span class="line">    mode_t f_mode; 读写模式：open的mod_t mode参数</span><br><span class="line">    off_t f_pos; 该文件在当前进程中的文件偏移量</span><br><span class="line">    /*...*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://p1lv91x5b.bkt.clouddn.com/struct_file.png" alt=""></p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="open操作"><a href="#open操作" class="headerlink" title="open操作"></a>open操作</h2><p>打开一个文件，内核都做了些什么呢？</p>
<ul>
<li>在进程打开文件表中找到一个未使用的文件描述符</li>
<li>申请一个新的文件管理结构file,根据不同的打开标志和mode产生不同的行为和file结构。</li>
<li>绑定文件描述符和对应的文件管理结构file，把文件描述符返回给用户。</li>
</ul>
<p>可见，open操作，内核主要消耗两种资源：文件描述符和文件管理结构file。</p>
<p>open参数</p>
<ul>
<li>pathname : 文件路径</li>
<li>flags: 打开标志</li>
<li>mode：文件的权限位，只在创建文件时需要，并受到umask的影响。</li>
</ul>
<p><strong>每一次open操作,都将分配一个文件描述符和文件管理结构,即使打开的是同一个文件.</strong></p>
<h2 id="close操作"><a href="#close操作" class="headerlink" title="close操作"></a>close操作</h2><p>close用于关闭文件描述符。而文件描述符可以是普通文件，也可以是设备，还可以是socket.在关闭时，VFS会根据不同的文件类型，执行不同的操作。这个实现机制由file结构的fop字段绑定的具体操作函数实现。</p>
<p><strong>遗忘close造成的问题</strong></p>
<ul>
<li>文件描述符没有释放</li>
<li>文件管理结构没有释放</li>
<li>对于普通进程，在进程结束时，内核自动回收；但是对于常驻进程，问题相当严重。</li>
</ul>
<p><strong>如何查找文件资源泄露</strong>——lsof命令</p>
<h2 id="文件偏移"><a href="#文件偏移" class="headerlink" title="文件偏移"></a>文件偏移</h2><p>文件偏移量是打开文件中比较重要的属性.它代表当前进程对<strong>当前打开文件</strong>的读写位置.一般情况下,读写操作都是从当前的偏移位置开始读写, 并且在读写结束之后更新偏移量.</p>
<p>刚打开文件时, 文件偏移量为0;</p>
<p>进程fork之后,父子进程的对同一打开文件的文件偏移量是一样的吗?后面解答.</p>
<h2 id="读文件-read"><a href="#读文件-read" class="headerlink" title="读文件_read"></a>读文件_read</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void* buf, size_t count);</span><br></pre></td></tr></table></figure>
<p>最一般意义,read尝试从fd中读取count个字节到用户定义缓冲区buf中,并返回实际成功读取的字节数.</p>
<p><strong>意外情况</strong>:返回值为-1</p>
<ul>
<li>errno = EAGAIN, EWOULDBLOCK: fd为非阻塞且没有数据可返回时</li>
<li>errno = EINTR: 信号中断</li>
</ul>
<p><strong>部分读取</strong></p>
<p>不同类型的文件出现部分读取的情况是不同的,根据具体绑定的fops-&gt;read函数而定:</p>
<ul>
<li>普通文件,到达文件末尾 EOF</li>
<li>socket文件系统的UDP: UDP报文数据长度小于参数len时,返回实际的数据长度</li>
<li>…(根据不同的类型小心处理)</li>
</ul>
<h2 id="写文件-write"><a href="#写文件-write" class="headerlink" title="写文件_write"></a>写文件_write</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void*buf, size_t count);</span><br></pre></td></tr></table></figure>
<p>write操作根据当前fd的文件偏移量, 写入count个字节数据.与read操作类似,同样会出现<strong>部分写</strong>的情况.</p>
<p><strong>追加写</strong>–O_APPEND</p>
<p>当使用O_APPEND以追加的形式打开文件的时候,每次写操作都会先定位到文件的末尾,然后再执行写操作.每次写操作获取到的都是文件(inode)的最新末尾位置(对inode加锁保护, 以避免多进程情况下竞争).</p>
<h2 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a>文件描述符的复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int dup(int oldfd);</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br><span class="line">int dup3(int oldfd, int newfd, int flags);</span><br></pre></td></tr></table></figure>
<ul>
<li>dup:使用一个最小的未使用的文件描述符作为复制后的文件描述符</li>
<li>dup2:使用用户指定的newfd来复制oldfd,如果newfd已经打开,就先关闭newfd,在复制oldfd(close+dup的原子性调用)</li>
<li>dup3:支持O_CLOEXEC.表示新复制的fd在fork并执行exec之后,将关闭.</li>
</ul>
<p><strong>复制的只是文件描述符</strong></p>
<p>新复制的文件描述符和旧的文件描述符指向的是同一个file文件管理结构,他们共享文件偏移量,文件读写模式,文件打开标志等等. file的创建仅仅在open操作的时候发生.</p>
<h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><h1 id="进程执行fork后，文件打开表和文件管理结构file"><a href="#进程执行fork后，文件打开表和文件管理结构file" class="headerlink" title="进程执行fork后，文件打开表和文件管理结构file"></a>进程执行fork后，文件打开表和文件管理结构file</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/学习之道/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shunlqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/shunlqing.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shunlqing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/学习之道/" itemprop="url">重新训练自己的大脑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T14:51:31+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/效率/" itemprop="url" rel="index">
                    <span itemprop="name">效率</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读《学习之道》，重新训练自己的大脑。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><ul>
<li>专注思维和发散思维</li>
<li>工作记忆和长期记忆</li>
<li>回想和提取练习</li>
<li>组块构建和避免能力错觉</li>
</ul>
<h3 id="专注思维和发散思维"><a href="#专注思维和发散思维" class="headerlink" title="专注思维和发散思维"></a>专注思维和发散思维</h3><p>大脑存在两种思维模式交替运作：专注模式和发散模式。专注模式擅长在经验、旧有的神经连接中寻找解决方法；发散模式（无意识思考）则是在不经意间触发灵感。</p>
<p>沉于专注模式太久，会陷入思维困境无法自拔；没有专注一段时间便进入发散模式，往往陷入“认知错觉”（总感觉自己在学习，但实际上没有）。</p>
<p>学习新概念新知识块，首先需要快速浏览总体把握，并且尽可能描述清楚发现的问题。之后带着清晰的问题进入深度阅读，在深度阅读的过程中，不断明确问题，并尝试求解。在一段时间（1小时），问题仍旧不能解决，此时要转移注意力，有意识地切换成发散模式（散步，听音乐）。反复之。</p>
<p>专注模式下，问题必须清晰。</p>
<h3 id="工作记忆和长期记忆"><a href="#工作记忆和长期记忆" class="headerlink" title="工作记忆和长期记忆"></a>工作记忆和长期记忆</h3><p>两种记忆系统：工作记忆和长期记忆</p>
<p>工作记忆是瞬时记忆，要想让工作记忆转存到长期记忆，需要时间也需要能量。也就是说，需要有时间表适时地不断排演重复，对其施加能量，才能触发生成长期的神经连接。一开始，最好24小时内回顾一次。之后每天重复一次，再后来，每周甚至几周重复一次。</p>
<p>这就意味着，需要有跟踪学习项目的记录。</p>
<h3 id="回想，提取练习"><a href="#回想，提取练习" class="headerlink" title="回想，提取练习"></a>回想，提取练习</h3><p>回想（提取练习）是比一遍遍阅读材料更有效的，但是常常被忽略。</p>
<p>学习时，自我测验和做提取练习时最有效果的。</p>
<p>初次学到、还颇有挑战性的知识，最好是24小时内亲近一下。然后几天，一周，几周，几个月。</p>
<p>要想考出好成绩或在此基础上创造性思考，你就必须让它们牢牢地钉在记忆里。</p>
<h3 id="组块构建和避免能力错觉"><a href="#组块构建和避免能力错觉" class="headerlink" title="组块构建和避免能力错觉"></a>组块构建和避免能力错觉</h3><p>要熟练的掌握知识，就要创造一些概念组块——通过<strong>赋予意义</strong>将分散的<strong>信息碎片</strong>组合起来的过程。</p>
<p><strong>构成组块的基本步骤</strong></p>
<ul>
<li>注意力集中在原始信息本身的意义上</li>
<li>理解信息形成组块的接口，即它对外界的意义</li>
<li>获取背景信息，反复推敲组块和外界的连接，即其存在的意义和何时何地使用它们</li>
</ul>
<p>搭建组块资料库的过程，也是训练大脑的过程。</p>
<p>仅仅看一遍问题答案，就以为自己会了，这就是能力错觉。从笔记里挑一个概念，看看自己能回忆起多少内容，同时试着理解所回忆的内容。此时，回想会发挥很大作用。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ul>
<li>Questions List</li>
<li>ToDo List</li>
<li>组块构建跟踪——笔记或Blog</li>
<li>番茄时间(专注模式)</li>
</ul>
<h3 id="Q-List"><a href="#Q-List" class="headerlink" title="Q List"></a>Q List</h3><p>每开始一次新知识的学习，准备问题列表。在专注模式在，不断清晰、明确、深刻对问题本身和答案的理解。</p>
<h3 id="组块构建跟踪"><a href="#组块构建跟踪" class="headerlink" title="组块构建跟踪"></a>组块构建跟踪</h3><p>笔记本专门一白页（简要）、组块构建是Blog或笔记的形式</p>
<p>根据组块构建的步骤，一开始不应是总结式的。</p>
<ul>
<li>按大类别，将碎片化的知识小块，逐个理解（其本身，接口，与外界联系）</li>
<li>心中已开始有全貌的认识，便开始整理、组块</li>
<li>在尚未基本固定下来整个知识架构之前，按一定的时间周期，不断回想提取、理解。</li>
</ul>
<h3 id="ToDo-List"><a href="#ToDo-List" class="headerlink" title="ToDo List"></a>ToDo List</h3><p>每天睡觉前，写下明天要做的重要的事项。</p>
<p>避免拖延。</p>
<h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul>
<li>战胜恐惧，别怕落在别人后面</li>
<li>拖延——令你没有足够时间处于专注模式，走马观花</li>
<li>好好睡觉</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/shunlqing.jpg"
                alt="shunlqing" />
            
              <p class="site-author-name" itemprop="name">shunlqing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shunlqing</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
